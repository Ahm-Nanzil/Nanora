
    <!-- ═══════════════════════════════════════════════════════
         SCROLL LINE SYSTEM — JavaScript (Chained Relay Dots)
    ═══════════════════════════════════════════════════════ -->
    <script>
    (function () {
        'use strict';

        gsap.registerPlugin(ScrollTrigger);

        /*
         * RELAY CHAIN LOGIC
         * ─────────────────
         * Each section has its own line (top → bottom).
         * A moving dot starts at top-of-section and travels to bottom-of-section
         * exactly synced to scroll progress for THAT section.
         *
         * The bottom of section N sits at the same pixel as the top of section N+1,
         * so the resting dot of section N visually "touches" the starting dot
         * of section N+1 — creating a seamless relay chain.
         *
         * Trigger window:
         *   start: 'top bottom'    → dot begins moving when section enters viewport
         *   end:   'bottom bottom' → dot stops when section bottom hits viewport bottom
         *
         * This makes the dot travel the full section height as you scroll through it.
         */

        var VB_H = 1000;  // viewBox height (SVG stretches to real px via preserveAspectRatio:none)
        var CX   = 3;     // center x in viewBox (viewBox width = 6)

        // ── Build one SVG for one side of one section
        function buildSVG(colorRgb, side) {
            var ns  = 'http://www.w3.org/2000/svg';
            var svg = document.createElementNS(ns, 'svg');
            svg.classList.add('vline-svg', 'vline-' + side);
            svg.setAttribute('aria-hidden', 'true');
            svg.setAttribute('viewBox', '0 0 6 ' + VB_H);
            svg.setAttribute('preserveAspectRatio', 'none');

            // Per-SVG unique gradient id
            var uid   = 'vlg-' + Math.random().toString(36).slice(2, 8);
            var isWht = colorRgb.indexOf('255,255,255') !== -1;
            var cFull = isWht ? 'rgba(255,255,255,0.9)' : 'rgba(' + colorRgb + ',0.9)';
            var cZero = isWht ? 'rgba(255,255,255,0)'   : 'rgba(' + colorRgb + ',0)';

            var defs = document.createElementNS(ns, 'defs');
            defs.innerHTML =
                '<linearGradient id="' + uid + '" x1="0" y1="0" x2="0" y2="1">' +
                  '<stop offset="0%"   stop-color="' + cZero + '"/>' +
                  '<stop offset="20%"  stop-color="' + cFull + '"/>' +
                  '<stop offset="80%"  stop-color="' + cFull + '"/>' +
                  '<stop offset="100%" stop-color="' + cZero + '"/>' +
                '</linearGradient>';

            // Track (dashed guide)
            var track = document.createElementNS(ns, 'line');
            track.classList.add('vl-track');
            track.setAttribute('x1', CX); track.setAttribute('y1', 0);
            track.setAttribute('x2', CX); track.setAttribute('y2', VB_H);
            track.setAttribute('vector-effect', 'non-scaling-stroke');
            track.style.stroke = 'rgba(' + colorRgb + ',0.18)';

            // Progress line (drawn by dashoffset, full gradient)
            var prog = document.createElementNS(ns, 'line');
            prog.classList.add('vl-progress');
            prog.setAttribute('x1', CX); prog.setAttribute('y1', 0);
            prog.setAttribute('x2', CX); prog.setAttribute('y2', VB_H);
            prog.setAttribute('vector-effect', 'non-scaling-stroke');
            prog.setAttribute('stroke', 'url(#' + uid + ')');
            prog.style.filter = 'drop-shadow(0 0 4px rgba(' + colorRgb + ',0.55))';

            // Static resting dot at TOP of section
            // (shows the connection point where previous section's dot handed off)
            var topDot = document.createElementNS(ns, 'circle');
            topDot.setAttribute('cx', CX); topDot.setAttribute('cy', 0); topDot.setAttribute('r', 4);
            topDot.setAttribute('vector-effect', 'non-scaling-stroke');
            topDot.style.fill    = 'rgba(' + colorRgb + ',0.4)';
            topDot.style.filter  = 'drop-shadow(0 0 4px rgba(' + colorRgb + ',0.4))';

            // Static resting dot at BOTTOM of section
            // (appears when moving dot arrives, stays as handoff point for next section)
            var botDot = document.createElementNS(ns, 'circle');
            botDot.classList.add('vl-rest-dot');
            botDot.setAttribute('cx', CX); botDot.setAttribute('cy', VB_H); botDot.setAttribute('r', 5.5);
            botDot.setAttribute('vector-effect', 'non-scaling-stroke');
            botDot.style.fill    = 'rgb(' + colorRgb + ')';
            botDot.style.filter  = 'drop-shadow(0 0 8px rgba(' + colorRgb + ',0.8)) drop-shadow(0 0 16px rgba(' + colorRgb + ',0.4))';
            botDot.style.opacity = '0';

            // Pulse ring (travels with moving dot)
            var ring = document.createElementNS(ns, 'circle');
            ring.classList.add('vl-ring');
            ring.setAttribute('cx', CX); ring.setAttribute('cy', 0); ring.setAttribute('r', 8);
            ring.setAttribute('vector-effect', 'non-scaling-stroke');
            ring.style.stroke = 'rgba(' + colorRgb + ',0.55)';

            // Moving dot (the star of the show)
            var dot = document.createElementNS(ns, 'circle');
            dot.classList.add('vl-dot');
            dot.setAttribute('cx', CX); dot.setAttribute('cy', 0); dot.setAttribute('r', 6);
            dot.setAttribute('vector-effect', 'non-scaling-stroke');
            dot.style.fill   = 'rgb(' + colorRgb + ')';
            dot.style.filter = 'drop-shadow(0 0 8px rgba(' + colorRgb + ',1)) drop-shadow(0 0 18px rgba(' + colorRgb + ',0.6))';

            svg.appendChild(defs);
            svg.appendChild(track);
            svg.appendChild(prog);
            svg.appendChild(topDot);
            svg.appendChild(botDot);
            svg.appendChild(ring);
            svg.appendChild(dot);

            return { svg: svg, prog: prog, dot: dot, ring: ring, botDot: botDot };
        }

        /*
         * KEY FIX — LINE POSITION
         * ────────────────────────
         * We measure the ACTUAL left edge of the first .container inside
         * each .scroll-line-section using getBoundingClientRect().
         * This gives us the exact pixel where the colored background ends
         * and the white outer space begins — regardless of Bootstrap breakpoints
         * or custom padding.
         *
         * The SVGs are absolutely positioned inside .scroll-line-section
         * (which is position:relative). We convert the container's page-relative
         * left/right to offsets relative to the section's own left edge.
         */
        function getContainerEdges(section) {
            /*
             * The section element itself IS the boundary.
             * Every section is a `container-xxl` which sits inside
             * `div.container-xxl.bg-white` — the white outer wrapper.
             * The section's own left/right edges are exactly where
             * the white space ends and the section content begins.
             *
             * So we measure the section's left edge relative to itself = 0.
             * But we need the offset relative to the viewport to find
             * how much white space is on each side.
             *
             * The outer bg-white wrapper fills 100vw.
             * The section (container-xxl) is max 1400px centered inside it.
             * We just need: how far is the section's left edge from viewport left?
             */
            var sRect = section.getBoundingClientRect();
            var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

            // Distance from left of page to left edge of section
            var leftFromPage  = sRect.left + scrollLeft;
            // Distance from right edge of section to right of viewport
            var rightFromPage = window.innerWidth - sRect.right + scrollLeft;

            return {
                left:  Math.max(0, sRect.left),   // px from section's own left to viewport left
                right: Math.max(0, window.innerWidth - sRect.right)  // px from section's right to viewport right
            };
        }

        // ── Set SVG position + height for a section
        function positionSection(section) {
            var edges = getContainerEdges(section);
            var h     = section.offsetHeight;
            section.querySelectorAll('.vline-svg').forEach(function (svg) {
                svg.style.height = h + 'px';
                if (svg.classList.contains('vline-left')) {
                    /*
                     * The SVG is position:absolute inside the section.
                     * section.getBoundingClientRect().left tells us how far
                     * the section is from the viewport left.
                     * We want the line at the section's own left edge = left:0
                     * relative to the section, but shifted by -half-linewidth
                     * so it straddles the boundary (half inside, half outside).
                     */
                    svg.style.left  = '-1px';
                    svg.style.right = '';
                } else {
                    svg.style.right = '-1px';
                    svg.style.left  = '';
                }
            });
        }

        // ── Attach ScrollTrigger to one SVG
        function wireScroll(d, section) {
            var DASH = VB_H;

            /*
             * CORRECT RELAY LOGIC
             * ════════════════════
             * Each section has TWO dots:
             *
             *  • botDot  — STATIC, always visible at the BOTTOM of the section.
             *              Never moves. Acts as the "target" and also the same pixel
             *              as the next section's topDot waiting position.
             *
             *  • dot     — the MOVING dot. Starts at the TOP (cy=0).
             *              Travels DOWN toward botDot (cy=VB_H) as you scroll.
             *              When it reaches botDot, they visually merge/touch.
             *              The next section's dot then begins its own journey.
             *
             * The progress line draws behind the moving dot as it travels.
             *
             * Scroll window:
             *   start: 'top bottom'   → dot begins the moment section scrolls into view
             *   end:   'bottom top'   → dot finishes when section fully exits the top
             *
             * This feels like the dot is "attached" to the scroll and travels
             * exactly with your finger/wheel through each section.
             */

            // Initial state: line undrawn, moving dot at top, botDot always visible
            gsap.set(d.prog,   { strokeDasharray: DASH, strokeDashoffset: DASH });
            gsap.set(d.dot,    { attr: { cy: 0 }, opacity: 1 });
            gsap.set(d.ring,   { attr: { cy: 0, r: 6 }, opacity: 0 });
            gsap.set(d.botDot, { opacity: 1 }); // ← always visible, never changes

            // Pulse timeline on the moving dot
            var pulse = gsap.timeline({ repeat: -1, paused: true });
            pulse
                .set(d.ring, { attr: { r: 6 }, opacity: 0.7 })
                .to(d.ring,  { attr: { r: 15 }, opacity: 0, duration: 1.0, ease: 'power2.out' });

            ScrollTrigger.create({
                trigger : section,
                start   : 'top bottom',   // dot starts moving as section enters viewport
                end     : 'bottom top',   // dot stops when section fully leaves top of viewport
                scrub   : 0.4,            // tight scrub so dot feels glued to scroll
                onUpdate: function (self) {
                    var p  = Math.max(0, Math.min(1, self.progress));
                    var cy = p * VB_H;

                    // Draw the progress line behind the moving dot
                    gsap.set(d.prog, { strokeDashoffset: DASH - (DASH * p) });

                    // Move the dot + ring downward
                    gsap.set(d.dot,  { attr: { cy: cy } });
                    gsap.set(d.ring, { attr: { cy: cy } });

                    // Pulse while moving (not at rest at top or bottom)
                    if (p > 0.02 && p < 0.98) {
                        if (!pulse.isActive()) pulse.restart();
                    } else {
                        pulse.pause();
                        gsap.set(d.ring, { opacity: 0 });
                    }

                    // When moving dot reaches botDot, hide the moving dot
                    // (they visually merge — the static botDot takes over)
                    if (p >= 0.97) {
                        gsap.set(d.dot, { opacity: 0 });
                    } else {
                        gsap.set(d.dot, { opacity: 1 });
                    }
                }
            });
        }

        // ── Main
        function init() {
            document.querySelectorAll('.scroll-line-section').forEach(function (section) {
                var color = section.dataset.vlineColor || '13,110,253';
                ['left', 'right'].forEach(function (side) {
                    var d = buildSVG(color, side);
                    section.appendChild(d.svg);
                    positionSection(section);
                    wireScroll(d, section);
                });
            });
        }

        // ── Resize
        var t;
        window.addEventListener('resize', function () {
            clearTimeout(t);
            t = setTimeout(function () {
                document.querySelectorAll('.scroll-line-section').forEach(positionSection);
                ScrollTrigger.refresh();
            }, 200);
        });

        window.addEventListener('load', init);

    })();
    </script>